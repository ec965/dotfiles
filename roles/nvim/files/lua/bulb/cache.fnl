(local M {:cache {:module {} :macro {}}})

;; auto generated header
(local t-auto-gen "-- This file is autogenerated by bulb\n")

(macro t-package-preload [module-name code-str]
  `(string.format "package.preload['%s'] = package.preload['%s'] or function()
%s
end
" ,module-name ,module-name ,code-str ,module-name
                  ,module-name))

(fn add [cache-type]
  (fn [filename module-name code]
    (assert (= (type code) :string) (.. "Code is not a string for: " filename))
    (tset (. M :cache cache-type) filename {: filename : module-name : code})))

(fn M.write-cache []
  ;; TODO: write macros to cache
  (let [{: write-file} (require :bulb.fs)
        cache-path (. (require :bulb.config) :cfg :cache-path)]
    (->> (accumulate [file-contents t-auto-gen _ {: module-name : code} (pairs M.cache.module)]
           (.. file-contents (t-package-preload module-name code)))
         (write-file cache-path))))

(fn M.gen-preload-cache []
  "Generate the preload file for all the files in the first runtime path"
  (let [{: get-fnl-files} (require :bulb.fs)
        {: compile-file} (require :bulb.compiler)
        {: add-module : write-cache : cache} (require :bulb.cache)
        {: get-module-name} (require :bulb)
        fnl-files (get-fnl-files (vim.fn.stdpath :config))]
    (vim.pretty_print fnl-files)
    (each [_ filename (ipairs fnl-files)]
      (if ;; if this is a macro, we don't want to compile it
          ;; the macro searcher should always fine our macro files before we start compiling
          (= (. cache.macro filename) nil)
          (let [module-name (get-module-name filename)]
            (if (not= nil module-name)
                (->> (compile-file filename)
                     (add-module filename module-name))))))
    (write-cache)))

(tset M :add-module (add :module))
(tset M :add-macro (add :macro))

M
